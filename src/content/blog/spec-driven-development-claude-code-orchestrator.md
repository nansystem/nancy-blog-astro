---
title: 仕様駆動開発の実践：Claude Codeで作るオーケストレーター型ワークフロー
description: Claude Codeのrules・skills・subagentを活用し、仕様駆動開発をオーケストレーター型ワークフローとして実践する方法を解説する。仕様テンプレート、CLAUDE.mdの設計、Taskツールによるサブエージェント活用の具体例を示す。
date: 2026-02-21T13:00:00+09:00
categories:
  - AI
permalink: /spec-driven-development-claude-code-orchestrator
published: false
---

<!-- textlint-disable -->

[仕様駆動開発（SDD）入門](/spec-driven-development)では、SDD の概念・ワークフロー・ツールを整理した。本記事はその実践編として、Claude Code で SDD を実現する具体的な方法を示す。

前提として、Claude Code の基本操作（チャット、ファイル編集、コマンド実行）は既知とする。

---

## 解くべき問題

### AI コーディングの課題

AI コーディングツールで開発速度は上がった。しかし、以下の問題が開発プロセスのボトルネックになっている。

1. **PR レビューが追いつかない** — AI の実装速度は人間のレビュー速度をはるかに超える。レビュアーは仕様なしにコードから意図を逆算しなければならず、認知負荷が高い
2. **プロンプトの試行錯誤** — 曖昧なプロンプトは意図と異なるコードを生成し、修正の往復がコンテキストウィンドウを消費して品質を下げる
3. **既存コードベースの規約・パターンを AI が把握できない** — 100 万行規模の既存コードベースに機能を追加する場合、AI は既存のアーキテクチャ・命名規約・実装パターンを把握せずにコードを生成する。結果として既存コードと一貫性のない実装が生まれる。[前記事](/spec-driven-development)で紹介した Kiro のステアリングドキュメントや spec-kit の Constitution は、プロジェクトの規約をコンテキストとして AI に提供することでこの課題に対処している

### 既存 SDD ツールの課題

[前記事](/spec-driven-development)で紹介した SDD はこれらの問題に対する構造的な回答である。spec-kit は `specify`（仕様作成）・`clarify`（Q&A による曖昧さ解消）・`plan`（技術設計）・`tasks`（タスク分解）・`analyze`（整合性チェック）・`implement`（実装）・`checklist`（チェックリスト生成）の 7 コマンドを提供し、SDD のワークフローをカバーしている。しかし、[実際の運用では課題が残る](/spec-driven-development#sdd-の理想と現実)。

4. **仕様が肥大化し、人間がレビューしきれない** — シンプルな機能でも AI が生成した仕様が 3,590 行以上に膨れ上がったケースが報告されている。Martin Fowler サイトの分析記事でも「これらのマークダウンファイルをすべてレビューするよりも、コードをレビューしたい」と指摘されている。仕様が肥大化すればレビュー負荷も増える。これは同じ問題の表裏である
5. **実装コードが仕様を満たしているか自動で検証できない** — spec-kit の `analyze` は仕様・設計・タスク間のドキュメント整合性をチェックするが、`implement` で生成された実装コードが仕様の受け入れ条件を満たしているかの検証は行わない。コードが書かれた後の「仕様 vs 実装」の照合は人間に委ねられている
6. **7 つのコマンドを人間が順次実行する** — spec-kit では `specify` → `clarify` → `plan` → `tasks` → `implement` の各コマンドを人間がトリガーする。Kiro も Requirements → Design → Tasks の各フェーズで人間の介入が必要である。仕様策定から実装完了まで一気通貫で自動実行する仕組みがない
7. **大きな機能でコンテキストが溢れる** — 複数タスクの実装結果が 1 つのコンテキストに蓄積し、後半のタスクほど品質が落ちる

## どうあるべきか

| 課題                                              | あるべき姿                                                                                                                                                         |
| ------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 1. PR レビューが追いつかない                      | 仕様が存在し、レビュアーは仕様 vs 実装の照合に集中できる                                                                                                           |
| 2. プロンプトの試行錯誤                           | 人間は「何を作りたいか」を 1〜2 行で伝えるだけ。構造化は Claude が行う                                                                                             |
| 3. 既存コードの規約・パターンを AI が把握できない | プロジェクトの規約・パターンを CLAUDE.md で明文化し、AI が常に既存コードの文脈を踏まえて実装する。タスク仕様の「参照資料」で踏襲すべき既存コードを具体的に指定する |
| 4. 仕様が肥大化し、レビューしきれない             | 人間がレビューするのは機能仕様の GO/NO-GO のみ。タスク仕様は Claude が内部で生成・消費する。「対象外」セクションで機能仕様のスコープ自体を制御する                 |
| 5. 実装コードの自動検証がない                     | reviewer サブエージェントが実装コードを読み、EARS 形式の受け入れ条件ごとに PASS/FAIL を自動判定する                                                                |
| 6. コマンドを人間が順次実行する                   | 仕様承認後はタスク分解→実装→レビュー→修正が完了報告まで自律実行される                                                                                              |
| 7. コンテキストが溢れる                           | 各タスクの実装は独立したサブエージェントで行い、他タスクの情報が混入しない                                                                                         |

本記事では、これを実現する `/sdd` スキルの設計と、それを支える Claude Code の仕組み（rules・skills・subagent）を具体的に示す。

---

## 仕様ファイルのフォーマットと作り方

SDD では 2 種類の仕様を使い分ける。機能全体を定義する**機能仕様**と、個々の実装単位を定義する**タスク仕様**である。この 2 層構造は、[Kiro の Requirements → Tasks](/spec-driven-development#kiro-が確立した-sdd-のワークフロー) と [spec-kit の Specify → Tasks](/spec-driven-development#spec-kit-のワークフロー) の両方に共通するパターンである。

これらの仕様を人間がゼロから手書きする必要はない。人間は「何を作りたいか」を 1〜2 行で伝え、Claude が対話で曖昧な箇所を洗い出し、構造化された仕様を生成する。人間の仕事は生成された仕様のレビューと GO/NO-GO の判断である。

### 機能仕様テンプレート

機能仕様は「何を作るか」「なぜ作るか」「どこまでが範囲か」を定義する。以下のテンプレートは、前記事で整理した Kiro の EARS 形式の受け入れ条件と、spec-kit のスコープ明示（対象外セクション）を取り入れたものである。Claude はこのフォーマットに従って仕様を生成する。

```markdown
# 機能仕様: {機能名}

## 概要

{1段落で何を作るかを記述する}

## 背景・動機

{なぜこの機能が必要か。解決したい課題は何か}

## 要件

### 要件 1: {要件名}

**目的:** {ユーザーストーリー形式: 〜として、〜したい}

#### 受け入れ条件

1. {EARS形式: 〜したとき、システムは〜しなければならない}
2. {EARS形式: 〜の場合、システムは〜しなければならない}

### 要件 2: {要件名}

...

## 非機能要件

- {パフォーマンス、セキュリティ等の制約があれば記述}

## 対象外

- {この機能に含めないことを明示する}
- {スコープ外を書くことで、Claudeの勝手な拡張を防ぐ}
```

#### 対話で仕様を作る

このテンプレートを人間が埋める必要はない。実際のワークフローでは、人間は 1〜2 行の自然言語を渡し、Claude が質問で曖昧さを解消してから仕様を生成する。

**人間の入力:**

```
ブログにタグ機能を追加したい。カテゴリとは別に、
記事横断のトピックをタグで表現できるようにする。
```

**Claude が確認する質問の例:**

```
機能仕様を作成するために、以下を確認させてください。

1. タグの管理方法: frontmatter に直接記述する想定か、
   それとも管理画面が必要か？
2. タグの表示位置: 記事ページのどこにタグを表示するか？
   （カテゴリの隣、記事末尾、サイドバー等）
3. タグ一覧ページ: /tags/{tag-name} のような
   タグ別記事一覧ページは必要か？
4. タグクラウド: 全タグを一覧表示するウィジェットは必要か？
5. 既存記事への影響: 既存記事に tags フィールドがない場合、
   どう扱うか？（空配列をデフォルトにするか）
```

人間が回答すると、Claude はテンプレートに沿った機能仕様を生成する。人間は生成された仕様をレビューし、修正点があれば指示する。このプロセスの具体的な実装（`/sdd` スキル）はセクション 4 で示す。

#### 受け入れ条件の書き方

受け入れ条件は EARS（Easy Approach to Requirements Syntax）形式で書く。EARS 形式の詳細は[前記事の要件定義セクション](/spec-driven-development#phase-1-要件定義)を参照。ここでは実践でよくある失敗パターンと修正例を示す。

| 失敗パターン                  | NG 例                                                    | OK 例（EARS 形式）                                                                                                                                                                           |
| ----------------------------- | -------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 曖昧な動詞                    | エラーを適切に処理する                                   | 認証失敗時、システムは 401 ステータスと `{ error: "INVALID_CREDENTIALS" }` を返さなければならない                                                                                            |
| 主語が不明                    | パスワードが検証される                                   | ユーザーがログインフォームを送信したとき、システムはパスワードをハッシュ値と照合しなければならない                                                                                           |
| 複数の振る舞いを 1 文に詰める | ログインし、セッションを作成し、ダッシュボードに遷移する | 3 つの受け入れ条件に分割: (1) 有効な認証情報を送信したとき、システムはセッションを作成しなければならない (2) セッションが作成されたとき、システムはダッシュボードに遷移しなければならない... |
| テスト不能                    | 高速に応答する                                           | システムは常に認証リクエストに 200ms 以内で応答しなければならない                                                                                                                            |

ポイントは 3 つ。**主語を「システムは」に固定する**こと。**1 つの受け入れ条件に 1 つの振る舞い**を書くこと。**「適切に」「素早く」を数値に置き換える**こと。

#### 機能仕様の生成例

以下は、上記の対話を経て Claude が生成する機能仕様の例である。

```markdown
# 機能仕様: ブログ記事のタグ機能

## 概要

ブログ記事にタグを付与し、タグごとの記事一覧ページを生成する。

## 背景・動機

カテゴリは大分類（AI、JavaScript 等）として機能しているが、
記事横断のトピック（例: 「パフォーマンス」「テスト」）を
表現する手段がない。タグによる細分類を追加し、
読者が関連記事を発見しやすくする。

## 要件

### 要件 1: タグのデータ定義

**目的:** 記事作成者として、frontmatter でタグを指定したい。

#### 受け入れ条件

1. 記事の frontmatter に tags フィールドが定義されたとき、
   システムはタグの配列としてパースしなければならない
2. tags フィールドが省略された場合、
   システムは空配列をデフォルト値としなければならない

### 要件 2: タグの表示

**目的:** 読者として、記事に付与されたタグを確認したい。

#### 受け入れ条件

1. 記事ページを表示したとき、システムは記事に付与された
   すべてのタグをカテゴリの下に表示しなければならない
2. タグが 0 件の場合、システムはタグ表示領域を
   非表示にしなければならない
3. 読者がタグをクリックしたとき、システムは
   `/tags/{tag-name}` に遷移しなければならない

### 要件 3: タグ別一覧ページ

**目的:** 読者として、特定タグの記事一覧を閲覧したい。

#### 受け入れ条件

1. タグ一覧ページを表示したとき、システムは
   該当タグを持つ記事を日付の降順で表示しなければならない
2. published が false の記事は、本番環境において
   タグ一覧ページに表示してはならない

## 非機能要件

- タグ一覧ページは静的生成（SSG）とする

## 対象外

- タグの管理画面（frontmatter で直接編集する）
- タグクラウド（全タグの一覧表示ウィジェット）
- タグによる検索・フィルタ機能
```

### タスク仕様テンプレート

タスク仕様は、機能仕様から分解された個別タスクの実装指示書である。タスクの分解とタスク仕様の生成は Claude が自律的に行う。人間が手書きする必要はない。

```markdown
## タスク指示書

### 概要

{1-2文でこのタスクで何を実装するかを記述}

### 参照資料

- 機能仕様: `specs/{feature}/requirements.md`
- 参照ファイル: `{踏襲すべき既存コードのパス}`（{何を参考にするか}）

### 要件

{機能仕様の要件から、このタスクに該当するものを抜粋}

1. {EARS 形式の受け入れ条件}
2. {EARS 形式の受け入れ条件}

### 制約

- {変更してはいけないファイル}
- {新規ファイルの配置先ルール}
- {使用すべき既存クラス・パターン}
```

#### タスク仕様の生成例

以下は、上記タグ機能の要件 3（タグ別一覧ページ）に対して Claude が生成するタスク仕様の例である。

```markdown
## タスク指示書

### 概要

タグ別の記事一覧ページを静的生成する。`/tags/{tag-name}` の
URL でアクセスでき、該当タグを持つ記事を日付降順で表示する。

### 参照資料

- 機能仕様: `specs/blog-tags/requirements.md`（要件 3）
- 参照ファイル: `src/pages/category/[category].astro`
  （カテゴリ一覧ページのパターンを踏襲する。
  getStaticPaths でのルート生成、published によるフィルタリング、
  日付降順ソートの実装を参考にする）
- スキーマ: `src/content.config.ts`（タスク 1 で追加された
  tags フィールドの定義）

### 要件

1. タグ一覧ページを表示したとき、システムは該当タグを持つ
   記事を日付の降順で表示しなければならない
2. published が false の記事は、本番環境において
   タグ一覧ページに表示してはならない

### 制約

- 新規ファイルは `src/pages/tags/` 配下に配置する
- 既存ファイルは変更しない（タスク 1 で追加された
  tags フィールドとコンポーネントを使用する）
- `src/pages/category/[category].astro` の
  実装パターン（getStaticPaths, フィルタリング、ソート）を
  踏襲する
```

参照資料に含まれる `src/pages/category/[category].astro` や `src/content.config.ts` といった具体的なファイルパスは、**人間が指定するのではなく、Claude が `/sdd` の Phase 3 でコードベースを探索して自動で発見する**。「タグ一覧ページを作る」という要件に対して、Claude は既存のカテゴリ一覧ページを類似パターンとして特定し、参照資料に含める。人間は機能仕様で「何を作るか」を伝えるだけでよい。

### Claude が正確に実装できる仕様の書き方

仕様の書き方によって、Claude の実装精度は大きく変わる。以下に、曖昧な仕様と具体的な仕様の対比を示す。

| 観点         | 曖昧な仕様（避ける）             | 具体的な仕様（推奨）                                                                            |
| ------------ | -------------------------------- | ----------------------------------------------------------------------------------------------- |
| 配置先       | 適切な場所に作成する             | `src/services/` 配下に `token.ts` を作成する                                                    |
| 振る舞い     | エラーを適切に処理する           | 認証失敗時は `401` を返し、レスポンスボディに `{ error: "INVALID_CREDENTIALS" }` を含める       |
| 参照パターン | 既存コードに合わせる             | `src/services/user.ts` の `createUser` 関数のパターンを踏襲する                                 |
| スコープ     | 必要に応じてリファクタリングする | 既存ファイルは変更しない。新規ファイルの追加のみ                                                |
| 入出力       | ユーザー情報を受け取る           | `{ email: string, password: string }` を受け取り、`{ token: string, expiresAt: string }` を返す |

ポイントをまとめる。

- **ファイルパスを具体的に指定する**: Claude がファイルの配置場所を推測する余地をなくす
- **入出力の型・値を明示する**: 振る舞いだけでなく、データの形を書く
- **やらないことを書く**: 「対象外」「制約」セクションでスコープ外を明示し、勝手な拡張を防ぐ
- **踏襲すべき既存コードを指定する**: 「参照資料」で具体的なファイル・関数を示し、パターンの一貫性を保つ

---

## Claude Code の仕組み化: rules / skills / subagent

Claude Code には、仕様駆動開発を支える 3 つの仕組みがある。rules（CLAUDE.md）、skills、subagent（Task ツール）である。それぞれの役割と使い方を整理する。

### rules: CLAUDE.md の設計パターン

CLAUDE.md はプロジェクトのルールを定義するファイルである。Claude Code はファイル操作時に該当ディレクトリの CLAUDE.md を自動で読み込む。

#### ルートの CLAUDE.md: プロジェクト全体のルール

プロジェクトルートに置く CLAUDE.md には、全体に適用されるルールを書く。

```markdown
# プロジェクトルール

## コーディング規約

- TypeScript を使用する。any 型は禁止
- 関数は必ず戻り値の型を明示する
- エラーハンドリングは Result 型パターンを使用する

## アーキテクチャ

- src/services/: ビジネスロジック
- src/routes/: HTTP ルーティング（ロジックを持たない）
- src/repositories/: データアクセス
- 依存の方向: routes → services → repositories

## 禁止事項

- console.log によるデバッグログを残さない
- 環境変数を直接参照しない（config モジュール経由）
- テストのないコードをコミットしない
```

#### スコープ付きルール

特定のファイルやディレクトリにのみ適用するルールを定義する方法が 2 つある。

**方法 1: 子ディレクトリに CLAUDE.md を置く**

`src/components/CLAUDE.md` のように、対象ディレクトリに CLAUDE.md を配置する。Claude はそのディレクトリのファイルを操作するときにオンデマンドで読み込む。

```markdown
# src/components/CLAUDE.md

## コンポーネント規約

- コンポーネントは関数コンポーネントで書く
- Props の型は同一ファイル内で定義する
- スタイルは CSS Modules を使用する
- テストは同一ディレクトリに {ComponentName}.test.tsx で配置する
```

**方法 2: `.claude/rules/` にパス指定ルールを置く**

`.claude/rules/` に Markdown ファイルを配置し、YAML frontmatter の `paths` でファイルパターンを指定する。ディレクトリを横断するルール（例: テストファイル全般）に向いている。

```markdown
# .claude/rules/test-rules.md

---

paths:

- "\*_/_.test.ts"
- "\*_/_.test.tsx"

---

## テスト規約

- テストは describe / it のネスト構造で書く
- モックは vi.mock を使用する
- テストファイル名は {対象ファイル名}.test.{ext} とする
```

| 方法                       | 適するケース                                                                           |
| -------------------------- | -------------------------------------------------------------------------------------- |
| 子ディレクトリの CLAUDE.md | そのディレクトリが独立したモジュール（例: `packages/ui/`）                             |
| `.claude/rules/` + paths   | ファイルパターンで横断的にルールを適用したい（例: テストファイル全般、API ルート全般） |

#### CLAUDE.md に書くべきこと・書かないこと

| 書くべきこと                                   | 書かないこと                             |
| ---------------------------------------------- | ---------------------------------------- |
| コーディング規約（命名、型、エラー処理）       | 特定タスクの実装手順（→ skills で定義）  |
| アーキテクチャの制約（レイヤー構成、依存方向） | 一時的なルール（→ プロンプトで直接指示） |
| 禁止事項（やってはいけないこと）               | 自明なルール（言語仕様レベルの常識）     |
| ファイル配置のルール                           | 環境固有の設定（→ .env 等）              |

### skills: 再利用可能なスキルの定義

skills は、Claude Code のスラッシュコマンドとして呼び出せる再利用可能な手順定義である。`.claude/skills/<name>/SKILL.md` に配置する。YAML frontmatter でメタデータを定義し、本文にプロンプトを書く。

仕様駆動開発では、以下のスキルが有用である。

#### 実装スキル（Coder）

タスク仕様を受け取り、実装を行うスキル。

```yaml
# .claude/skills/implement/SKILL.md
---
name: implement
description: タスク指示書に基づいてコードを実装する
argument-hint: "<task-spec-path>"
---

タスク指示書のファイルパス: $ARGUMENTS

## 行動規則
1. タスク指示書を読み、「参照資料」に記載されたファイルをすべて確認する
2. 「要件」を満たすコードを実装する
3. 「制約」に記載された禁止事項を遵守する
4. タスク指示書に記載のないことは実装しない
5. 実装が完了したら、変更したファイルの一覧を報告する

## やらないこと
- タスク指示書に記載のない機能の追加
- 既存コードのリファクタリング（指示書に明記されている場合を除く）
```

呼び出し方: `/implement specs/auth/task-1.md`

#### レビュースキル（Reviewer）

実装結果を仕様と照合し、レビューするスキル。

```yaml
# .claude/skills/review/SKILL.md
---
name: review
description: 実装がタスク指示書の要件を満たしているかを検証する
argument-hint: "<task-spec-path>"
---

タスク指示書のファイルパス: $ARGUMENTS

## レビュー観点
1. **要件充足**: タスク指示書の各要件が実装されているか
2. **制約遵守**: 制約に記載された禁止事項に違反していないか
3. **コード品質**: CLAUDE.md のルールに準拠しているか
4. **スコープ**: タスク指示書に記載のない変更が含まれていないか

## 出力フォーマット
- 各要件について PASS / FAIL を判定する
- FAIL の場合は具体的な理由と修正指針を示す
- 最終判定: APPROVE / REQUEST_CHANGES
```

呼び出し方: `/review specs/auth/task-1.md`

### subagent: カスタムサブエージェントの定義と活用

サブエージェントは、Claude Code が Task ツールで起動する専用のエージェント（サブプロセス）である。組み込みのエージェントタイプ（Explore、Plan、general-purpose 等）に加え、`.claude/agents/` にカスタムサブエージェントを定義できる。

#### カスタムサブエージェントの定義

`.claude/agents/` に Markdown ファイルを配置する。YAML frontmatter でツール・モデル・スキルを指定し、本文にプロンプトを書く。

```yaml
# .claude/agents/coder.md
---
name: coder
description: タスク指示書に基づいてコードを実装するエージェント
model: sonnet
tools:
  - Read
  - Write
  - Edit
  - Bash
  - Grep
  - Glob
skills:
  - implement
---
あなたは Coder（実装担当）である。
与えられたタスク指示書に基づいてコードを実装する。
CLAUDE.md のプロジェクトルールに従うこと。
タスク指示書に記載のないことは実装しない。
```

```yaml
# .claude/agents/reviewer.md
---
name: reviewer
description: 実装結果をタスク仕様と照合するエージェント
model: sonnet
tools:
  - Read
  - Grep
  - Glob
skills:
  - review
---
あなたは Reviewer（レビュー担当）である。
実装がタスク指示書の要件を満たしているかを検証する。
コードの変更は行わない。読み取り専用で検証する。
```

**制約:** サブエージェントはサブエージェントを起動できない。ネストが必要な場合は、メインの会話（またはインラインスキル）から順次起動する。

#### 活用パターン

##### パターン 1: 調査の並列実行

複数ファイルの調査を同時に行い、結果を統合する。

```
Human: この機能の影響範囲を調査して

Claude: （内部で複数の Task を並列起動）
  - Task 1 (Explore): src/services/ 配下の依存関係を調査
  - Task 2 (Explore): テストファイルの関連箇所を調査
  - Task 3 (Explore): API ルーティングの参照箇所を調査
→ 3つの結果を統合して報告
```

##### パターン 2: 実装と検証の分離

実装エージェントと検証エージェントを分離し、実装後に自動で検証を行う。

```
Human: /implement specs/auth/task-1.md

Claude: （skills で実装を実行後、Task で検証を起動）
  - 実装完了後、Task (general-purpose): 実装結果をタスク仕様と照合
→ 検証結果を報告
```

##### パターン 3: 複数タスクの並列実装

依存関係のないタスクを並列に実行する。タスク仕様に `(P)` マーカーが付いたタスクが対象である。

```
Human: task-1.md と task-2.md を並列で実装して

Claude: （内部で複数の Task を並列起動）
  - Task 1 (general-purpose): task-1.md の実装
  - Task 2 (general-purpose): task-2.md の実装
→ 両方の完了を待って結果を報告
```

### 使い分けの指針

| 仕組み   | 定義場所                         | 何をするか                 | いつ使うか                 |
| -------- | -------------------------------- | -------------------------- | -------------------------- |
| rules    | `CLAUDE.md` / `.claude/rules/`   | 常時適用されるルールを定義 | プロジェクト設定時         |
| skills   | `.claude/skills/<name>/SKILL.md` | 再利用可能な手順を定義     | 繰り返す作業がある時       |
| subagent | `.claude/agents/<name>.md`       | 特化型エージェントを定義   | 役割分離・並列実行したい時 |

3 つは排他的ではなく、組み合わせて使う。rules でルールを定義し、skills で手順をテンプレート化し、subagent で並列実行する。

---

## オーケストレーター型ワークフローの実践

ここまでに紹介した rules・skills・subagent を組み合わせ、仕様策定から実装完了まで 1 コマンドで実行する `/sdd` スキルを定義する。これが Orchestrator（指揮者）の実体である。

### Orchestrator とは何か

本記事における Orchestrator とは、**メインの会話コンテキストで動くインラインスキル**のことである。

スキルには `context: fork`（別プロセスで実行）を付けるオプションがあるが、Orchestrator スキルはこれを付けない。メインの会話コンテキストで動くことで、以下の 2 つが同時に使える。

- **Task ツール**: サブエージェント（coder、reviewer）を起動して並列実行
- **AskUserQuestion**: ワークフローの途中で人間に承認を求める

この 2 つの組み合わせが「承認を挟みつつ、自律的に完了まで実行する」ワークフローを実現する。

さらに、この構造にはコンテキストウィンドウの効率化という利点がある。各サブエージェント（coder、reviewer）は**独自のコンテキストウィンドウ**で動く。サブエージェントに渡されるのはタスク仕様と関連ファイルだけであり、Orchestrator の会話履歴や他タスクの実装結果は含まれない。タスクが 5 つあっても、各 coder は自分のタスク仕様だけに集中できる。

### `/sdd` スキルの定義

```yaml
# .claude/skills/sdd/SKILL.md
---
name: sdd
description: 対話で機能仕様を策定し、タスク分解→実装→レビューまで自動実行する
argument-hint: "<自然言語での機能説明>"
disable-model-invocation: true
allowed-tools: Task, AskUserQuestion, Read, Write, Edit, Grep, Glob
---

ユーザーの機能説明: $ARGUMENTS

以下のワークフローを順に実行する。

## Phase 1: 対話による仕様策定（質問あり）

1. $ARGUMENTS の内容を分析する
2. 機能仕様を作成するために不足している情報を特定する
   - スコープ: 何を含み、何を含まないか
   - 振る舞い: 正常系・異常系・境界条件
   - 既存コードとの関係: 参照すべきパターン、変更禁止の範囲
   - 非機能要件: パフォーマンス、セキュリティ等の制約
3. AskUserQuestion で不足情報をまとめて質問する
   - 質問は 1 回にまとめる。追加質問は行わない
   - 推測できる項目は推測し、質問数を最小限にする
4. 回答をもとに機能仕様テンプレートに沿った仕様を生成する
   - 受け入れ条件は EARS 形式で書く
   - 対象外セクションを必ず含める
5. 生成した機能仕様をユーザーに提示する
6. AskUserQuestion で GO / NO-GO の判断をユーザーに求める
   - NO-GO の場合: フィードバックを反映して仕様を修正し、再度提示する
   - GO の場合: 仕様を specs/{feature}/requirements.md に保存し、Phase 2 に進む

## Phase 2: タスク分解（自動）

1. 機能仕様を分析し、実装タスクに分解する
2. 各タスクの粒度は以下を基準に自律的に判断する:
   - 変更対象ファイルが 3〜5 ファイルに収まる
   - 1 つのタスクが 1 つの責務を持つ
   - 依存関係が明確
3. 依存関係のないタスクには (P) マーカーを付ける
4. 各タスクに対応する要件 ID を紐づける
5. タスクリストを specs/{feature}/tasks.md に保存する

## Phase 3: タスク仕様の生成（自動）

1. 各タスクについてタスク指示書を生成する
2. タスク指示書には以下を含める:
   - 概要
   - 参照資料（機能仕様へのパス、踏襲すべき既存ファイル）
   - 要件（機能仕様からの抜粋、EARS 形式）
   - 制約（変更禁止ファイル、配置先ルール）
3. specs/{feature}/task-{n}.md として保存する

## Phase 4: 実装（自動）

1. タスクリストの依存関係を分析する
2. 依存関係のない (P) タスクは Task ツールで並列実行する
3. 各タスクの実装には coder サブエージェントを使用する
4. 依存関係のあるタスクは前のタスク完了後に順次実行する

## Phase 5: レビューと修正（自動）

1. タスクごとに reviewer サブエージェントで検証する
2. 各タスク指示書の要件に対して PASS / FAIL を判定する
3. FAIL がある場合は以下の修正ループを実行する:
   a. FAIL の要件・理由・reviewer の指摘を修正指示に含める
   b. coder サブエージェントに修正指示を渡して修正する
   c. 再度 reviewer サブエージェントで検証する
   d. 同じ要件が 2 回連続で FAIL した場合はそのタスクの修正を打ち切る
4. 最終結果をユーザーに報告する:
   - 各要件の PASS / FAIL 一覧
   - 変更したファイルの一覧
   - 未解決の FAIL がある場合: 失敗理由と試みた修正内容を報告する

## 重要なルール
- Phase 1 の GO 判定後は、ユーザーに質問せず Phase 5 の完了報告まで自律的に実行する
- 実装中に判断が必要な場合は、機能仕様と CLAUDE.md のルールに基づいて判断する
- 仕様に書かれていないことは実装しない

## コンテキスト管理
- 中間成果物（機能仕様、タスクリスト、タスク仕様）はすべてファイルに保存する。会話コンテキストに全文を保持しない
- サブエージェントの実行結果は要約（変更ファイル一覧、PASS/FAIL 結果）のみ保持する。実装の詳細はサブエージェント内で完結させる
- 各 coder サブエージェントにはタスク仕様ファイルのパスだけを渡す。サブエージェントがファイルを読んで実装する
```

### 使い方

```
/sdd ブログにタグ機能を追加したい。カテゴリとは別に、記事横断のトピックをタグで表現できるようにする。
```

この 1 コマンドで以下が実行される。

```
人間: /sdd ブログにタグ機能を追加したい...
  ↓
Claude: 不足情報を質問（1 回のみ）
  ↓
人間: 回答する
  ↓
Claude: 機能仕様を生成して提示 → GO / NO-GO を確認
  ↓ GO
Claude: タスク分解（自動）
  ↓
Claude: タスク仕様を生成（自動）
  ↓
Claude: 実装（coder サブエージェント × 並列）
  ↓
Claude: レビュー（reviewer サブエージェント）
  ↓ FAIL → 失敗理由を含めて coder に修正指示 → 再レビュー
  ↓       同じ要件が 2 回連続 FAIL → 打ち切り
Claude: 最終結果を報告（未解決の FAIL があればその内容も）
```

人間が介入するのは 2 箇所だけ。**不足情報への回答**と **GO/NO-GO の判断**である。GO の後は、Claude が完了報告まで自律的に実行する。

### Orchestrator としての人間の役割

| 人間がやること                 | Claude（`/sdd` スキル）がやること |
| ------------------------------ | --------------------------------- |
| 作りたい機能を 1〜2 行で伝える | 不足情報の質問を生成する          |
| 不足情報に回答する             | 回答を機能仕様に構造化する        |
| 機能仕様の GO/NO-GO を判断する | タスク分解と粒度の決定            |
| 最終結果を確認する             | タスク仕様の生成                  |
|                                | 実装（サブエージェント並列実行）  |
|                                | レビュー・自動修正                |

人間の仕事は「何を作りたいか」を伝え、仕様に GO を出し、結果を受け取ることである。タスクの分解・粒度の決定・実装・レビューはすべて Claude が自律的に行う。

---

## 実践 Tips

### 仕様の粒度の調整

`/sdd` スキルはタスクの粒度を自律的に決定するが、結果がうまくいかない場合は機能仕様の書き方にフィードバックする。

**粒度が粗すぎるサイン（実行後にわかる）:**

- Claude が仕様に書かれていない判断をしている
- レビューで FAIL が多発する
- 実装結果が期待と異なる

→ 対処: 機能仕様の受け入れ条件を具体化する。入出力の型、エラー時の振る舞い、参照すべき既存コードを追記して `/sdd` を再実行する

**粒度が細かすぎるサイン:**

- 仕様の対話に実装より長い時間がかかっている
- Phase 1 の質問数が多すぎる

→ 対処: 機能説明をより抽象的にし、詳細は Claude の判断に委ねる。「対象外」セクションでスコープだけ明確にすれば、内部の設計判断は Claude が行える

### うまくいかないときの対処法

| 症状                       | 原因                 | 対処                                             |
| -------------------------- | -------------------- | ------------------------------------------------ |
| 実装が仕様と異なる         | 受け入れ条件が曖昧   | 入出力の型と具体的な値を機能仕様に追記する       |
| 既存コードが壊れる         | 制約の記載漏れ       | Phase 1 の回答で「変更しないファイル」を明示する |
| 不要な機能が追加される     | スコープ外が未定義   | Phase 1 の回答で「対象外」を明示する             |
| コンテキスト超過で品質低下 | 機能が大きすぎる     | 機能を分割して `/sdd` を複数回実行する           |
| 既存パターンと不一致       | 参照コードの指定漏れ | 機能説明に「〜のパターンを踏襲」と明記する       |
| rules が無視される         | ルールの配置が不適切 | `.claude/rules/` のパス指定が正しいか確認する    |

---

## まとめ

仕様駆動開発を Claude Code で実践するためのポイントを整理する。

- **仕様は対話で作る**: 人間は 1〜2 行の機能説明を渡し、Claude が質問で曖昧さを解消して構造化された仕様を生成する。テンプレートを手書きする必要はない
- **3 つの仕組みを組み合わせる**: rules（`CLAUDE.md` / `.claude/rules/`）で常時ルールを、skills（`.claude/skills/`）で手順を、subagent（`.claude/agents/`）で並列実行を定義する
- **Orchestrator はスキル**: `/sdd` インラインスキルが仕様策定→タスク分解→実装→レビューを 1 コマンドで制御する。人間の介入は「不足情報への回答」と「GO/NO-GO」の 2 箇所だけ
- **GO の後は自律実行**: 仕様承認後は Claude が完了報告まで自律的に実行する。タスクの粒度決定・実装・レビュー・修正はすべて Claude が行う

まずは `/sdd` スキルをプロジェクトに配置し、小さな機能で試してみるとよい。仕様を介した開発は、プロンプトの試行錯誤より速く、レビューの負荷も軽い。
