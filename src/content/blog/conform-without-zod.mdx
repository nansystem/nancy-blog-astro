---
title: "ConformがZodなしでやってくれること"
description: "Conformはバリデーションライブラリではない。HTML属性の自動生成、defaultValueとlastResultによる状態管理、エラーの振り分けをテストコードで検証する。"
date: 2026-02-11T12:00:00+09:00
categories:
  - React
permalink: /conform-without-zod
published: true
---

## この記事でやること

業務ではConform + Zodをセットで使うことが多いと思う。ただ、学ぶときは要素を1つでも減らして対象を絞るほうが理解しやすい。遠回りに見えるかもしれないが、まずConformだけで何ができて何ができないのかを確認したい。

Conformが担っているのはバリデーションよりも、HTML属性の自動生成、defaultValueとlastResultによる状態管理、エラーの振り分けのほうだ。Zodを外すと、それが見えてくる。

```
useForm
  ├─ getFormProps  → form要素にid, noValidate, onSubmitを設定
  ├─ getInputProps → input要素にname, id, type, required, aria-*を自動生成
  ├─ fields.*      → 各フィールドのid, errors, errorIdを管理
  └─ form.status   → submit結果を宣言的に管理（success / error）
```

この記事では、Vitest + Testing Libraryのテストコードだけで、Conformが「Zodなしで何をしてくれるのか」を3つの観点で検証する。

1. HTML属性の自動生成
2. defaultValueとlastResult
3. フィールドエラーとフォームエラー

## 検証環境

```bash
npm create vite@latest conform-without-zod -- --template react-ts
cd conform-without-zod
npm install
npm install @conform-to/dom @conform-to/react
npm install -D vitest @testing-library/react @testing-library/jest-dom jsdom
```

`vitest.config.ts` を作成する。

```ts
// vitest.config.ts
import { defineConfig } from "vitest/config";
import react from "@vitejs/plugin-react";

export default defineConfig({
  plugins: [react()],
  test: {
    environment: "jsdom",
    globals: true,
    setupFiles: "./src/test-setup.ts",
  },
});
```

```ts
// src/test-setup.ts
import "@testing-library/jest-dom/vitest";
```

`package.json` に `test` スクリプトを追加する。

```json
{
  "scripts": {
    "test": "vitest"
  }
}
```

これで `npm test` でテストが実行できる。

## useFormの基本 — formとfieldsを受け取る

Conformではまず `useForm` フックを呼ぶ。戻り値の `form` と `fields` を使って、フォームのHTML属性を生成する。

```tsx
// useForm の戻り値は [form, fields] の2要素
// <SignupSchema> を渡すと fields.email, fields.password が型安全になる（省略も可）
const [form, fields] = useForm<SignupSchema>({
  id: "signup",       // フォームの識別子
  constraint: {       // 省略可。HTMLバリデーション属性を設定する
    email: { required: true },
    password: { required: true, minLength: 8 },
  },
});

// → id="signup" novalidate="" ← ブラウザ標準のバリデーションUIを無効化
<form {...getFormProps(form)}>

// → required="" id="signup-email" form="signup" type="email" name="email"
<input {...getInputProps(fields.email, { type: "email" })} />
```

型パラメータ `<SignupSchema>` を渡すと、`fields` のキーが型安全になる。`fields.email` は存在するが `fields.phone` はコンパイルエラーになる。

では、このコードが実際にどんなHTMLを生成するのか見てみよう。

<div class="side-by-side">
<div class="side-by-side-panel" data-label="書くコード">

```tsx
import { useForm, getFormProps, getInputProps } from "@conform-to/react";

interface SignupSchema {
  email: string;
  password: string;
}

const [form, fields] = useForm<SignupSchema>({
  id: "signup",
  constraint: {
    email: { required: true },
    password: { required: true, minLength: 8 },
  },
});

return (
  <form {...getFormProps(form)}>
    <label htmlFor={fields.email.id}>メールアドレス</label>
    <input {...getInputProps(fields.email, { type: "email" })} />

    <label htmlFor={fields.password.id}>パスワード</label>
    <input {...getInputProps(fields.password, { type: "password" })} />
  </form>
);
```

</div>
<div class="side-by-side-panel" data-label="生成されるHTML">

```html
<form id="signup" novalidate="">
  <label for="signup-email">メールアドレス</label>
  <input required="" id="signup-email" form="signup" type="email" name="email" />

  <label for="signup-password">パスワード</label>
  <input
    required=""
    id="signup-password"
    form="signup"
    minlength="8"
    type="password"
    name="password"
  />
</form>
```

</div>
</div>

### 生成されたHTMLを見て気になるところ

#### `signup-email` というidはどこから来た？

Conformが `formId-fieldName` の規則で自動生成している。`label` の `for` と一致するので、ラベルクリックでinputにフォーカスが当たり、スクリーンリーダーも両者の関係を認識できる。

#### `getInputProps` の第2引数 `{ type: "email" }` は何？

`type` だけは自動で判断できないため、第2引数で指定する。

| 第2引数                | 用途                 |
| ---------------------- | -------------------- |
| `{ type: "text" }`     | 一般的なテキスト入力 |
| `{ type: "email" }`    | メールアドレス入力   |
| `{ type: "password" }` | パスワード入力       |
| `{ type: "number" }`   | 数値入力             |
| `{ type: "checkbox" }` | チェックボックス     |
| `{ type: "hidden" }`   | 隠しフィールド       |

#### `constraint` で `required: true` にしたのに、HTMLでは `required=""` になっている？

HTMLの[論理属性](https://developer.mozilla.org/ja/docs/Glossary/Boolean/HTML)は属性の有無で判定されるので、`required=""` と `required` は同じ意味だ。

#### `constraint` で指定できるプロパティは？

`constraint` は省略可能で、指定した値がそのまま `<input>` の `required` や `minlength` 属性になる。

ただしConformはJS読み込み後に `noValidate` を付与するため、JS動作中は `constraint` の属性はバリデーションとして機能しない。JS読み込み前の[ブラウザ標準バリデーション](https://developer.mozilla.org/ja/docs/Web/HTML/Constraint_validation)のフォールバック用だ。

**Zodなしの状態でsubmitボタンを押すと、クライアント側では何もチェックされずフォームがそのまま送信される。**

## defaultValueとlastResult

`getInputProps` は `value` ではなく `defaultValue` を返す。入力値はReactのstateではなく[DOMからFormData経由で取得する](https://conform.guide/)設計だ。

`lastResult` にはフォーム送信後のバリデーション結果（`status`, `initialValue`, `error`）を渡す。Conformがエラー表示や入力値の再セットを行う。未送信時は `lastResult` を渡さないので `form.status` は `undefined` になる。

<div class="side-by-side">
<div class="side-by-side-panel" data-label="コンポーネント">

```tsx
// src/components/form-metadata.tsx
import { useForm, getFormProps, getInputProps } from "@conform-to/react";
import type { SubmissionResult } from "@conform-to/dom";

interface ProfileSchema {
  username: string;
  bio: string;
}

interface ProfileFormProps {
  lastResult?: SubmissionResult<string[]> | null;
}

export function ProfileForm({ lastResult }: ProfileFormProps) {
  const [form, fields] = useForm<ProfileSchema>({
    id: "profile",
    defaultValue: {
      username: "ゲスト",
      bio: "",
    },
    // フォーム送信後のバリデーション結果を渡す。未送信ならundefined
    lastResult: lastResult ?? undefined,
  });

  return (
    <form {...getFormProps(form)}>
      <div>
        <label htmlFor={fields.username.id}>ユーザー名</label>
        <input {...getInputProps(fields.username, { type: "text" })} />
      </div>
      <div>
        <label htmlFor={fields.bio.id}>自己紹介</label>
        <input {...getInputProps(fields.bio, { type: "text" })} />
      </div>

      {/* form.statusは "success" | "error" | undefined */}
      <output data-testid="form-status">{form.status ?? "未送信"}</output>

      <button type="submit">保存</button>
    </form>
  );
}
```

</div>
<div class="side-by-side-panel" data-label="テスト">

```tsx
// src/components/form-metadata.test.tsx
import { render, screen } from "@testing-library/react";
import { describe, expect, it } from "vitest";
import type { SubmissionResult } from "@conform-to/dom";
import { ProfileForm } from "./form-metadata";

describe("ProfileForm - defaultValueとlastResult", () => {
  it("defaultValueが初期値としてinputに反映される", () => {
    render(<ProfileForm />);

    const usernameInput = screen.getByLabelText("ユーザー名") as HTMLInputElement;
    expect(usernameInput).toHaveValue("ゲスト");
  });

  it("defaultValueが空文字のフィールドは空で表示される", () => {
    render(<ProfileForm />);

    const bioInput = screen.getByLabelText("自己紹介") as HTMLInputElement;
    expect(bioInput).toHaveValue("");
  });

  it("lastResultなしの場合statusは未定義", () => {
    render(<ProfileForm />);

    expect(screen.getByTestId("form-status")).toHaveTextContent("未送信");
  });

  it("lastResultでstatus='success'の場合成功状態が反映される", () => {
    const lastResult: SubmissionResult<string[]> = {
      status: "success",
      // 送信時の入力値。
      // エラー時にユーザーが入力した値をフォームに再表示するために使われる
      initialValue: { username: "太郎", bio: "こんにちは" },
    };

    render(<ProfileForm lastResult={lastResult} />);

    expect(screen.getByTestId("form-status")).toHaveTextContent("success");
  });

  it("lastResultでstatus='error'の場合エラー状態が反映される", () => {
    const lastResult: SubmissionResult<string[]> = {
      status: "error",
      initialValue: { username: "", bio: "" },
      error: {
        username: ["ユーザー名は必須です"],
      },
    };

    render(<ProfileForm lastResult={lastResult} />);

    expect(screen.getByTestId("form-status")).toHaveTextContent("error");
  });

  it("getInputPropsがdefaultValueを返す（valueではない＝uncontrolled）", () => {
    render(<ProfileForm />);

    const usernameInput = screen.getByLabelText("ユーザー名") as HTMLInputElement;

    // HTMLInputElementのdefaultValueプロパティで確認
    expect(usernameInput.defaultValue).toBe("ゲスト");
    // React uncontrolledパターン: DOMのvalue属性で管理
    expect(usernameInput.value).toBe("ゲスト");
  });
});
```

</div>
</div>

### parse()とreply()

テストでは `SubmissionResult` を手書きして `useForm` に渡した。

```ts
const lastResult: SubmissionResult<string[]> = {
  status: "error",
  initialValue: { username: "", bio: "" },
  error: {
    username: ["ユーザー名は必須です"],
  },
};
```

実際のアプリではこのオブジェクトを手書きしない。`@conform-to/dom` が提供する `parse()` 関数で組み立てる。

```ts
import { parse } from "@conform-to/dom";

// formData はブラウザのFormData API。値の取得は formData.get("username") のようにする
// parse() がこれを { username: "太郎", bio: "こんにちは" } に変換して payload として渡す
const submission = parse(formData, {
  resolve(payload) {
    // キー: フィールド名、値: エラーメッセージの配列
    const error: Record<string, string[]> = {};

    if (!payload.username) {
      error.username = ["ユーザー名は必須です"];
    }

    if (Object.keys(error).length > 0) {
      return { error };
    }
    return { value: payload };
  },
});

// reply() はバリデーション結果を useForm の lastResult が受け取れる形式に変換する
const lastResult = submission.reply();
```

- `parse()`: FormDataをオブジェクトに変換し、`resolve` 内のバリデーションを実行する
- `reply()`: バリデーション結果から `SubmissionResult` を返す。送信値を `initialValue`（フォーム再表示用の値）に変換し、`status` と `error` を含む
- `SubmissionResult`: `error` のキーがフィールド名と対応しており、Conformが `fields.username.errors` に振り分ける。次のセクションでエラーの表示方法を詳しく見ていく

## フィールドエラーとフォームエラー

Conformはエラーをフィールドエラー（`fields.*.errors`）とフォームエラー（`form.errors`）に分けている。`lastResult` の `error` オブジェクトで、キーが `""` （空文字）ならフォームエラー、フィールド名ならフィールドエラーとして振り分けられる。

<div class="side-by-side">
<div class="side-by-side-panel" data-label="コンポーネント">

```tsx
// src/components/error-structure.tsx
import { useForm, getFormProps, getInputProps, getTextareaProps } from "@conform-to/react";
import type { SubmissionResult } from "@conform-to/dom";

interface ContactSchema {
  name: string;
  email: string;
  message: string;
}

interface ContactFormProps {
  lastResult?: SubmissionResult<string[]> | null;
}

export function ContactForm({ lastResult }: ContactFormProps) {
  const [form, fields] = useForm<ContactSchema>({
    id: "contact",
    lastResult: lastResult ?? undefined,
    constraint: {
      name: { required: true },
      email: { required: true },
      message: { required: true, minLength: 10 },
    },
  });

  return (
    <form {...getFormProps(form)}>
      {/* フォームレベルエラー */}
      {form.errors && (
        <div role="alert" id={form.errorId}>
          {form.errors.map((error, i) => (
            <p key={i}>{error}</p>
          ))}
        </div>
      )}

      <div>
        <label htmlFor={fields.name.id}>名前</label>
        <input {...getInputProps(fields.name, { type: "text" })} />
        {/* フィールドレベルエラー */}
        {fields.name.errors && (
          <div id={fields.name.errorId} role="alert">
            {fields.name.errors.map((error, i) => (
              <p key={i}>{error}</p>
            ))}
          </div>
        )}
      </div>

      <div>
        <label htmlFor={fields.email.id}>メールアドレス</label>
        <input {...getInputProps(fields.email, { type: "email" })} />
        {fields.email.errors && (
          <div id={fields.email.errorId} role="alert">
            {fields.email.errors.map((error, i) => (
              <p key={i}>{error}</p>
            ))}
          </div>
        )}
      </div>

      <div>
        <label htmlFor={fields.message.id}>メッセージ</label>
        <textarea {...getTextareaProps(fields.message)} />
        {fields.message.errors && (
          <div id={fields.message.errorId} role="alert">
            {fields.message.errors.map((error, i) => (
              <p key={i}>{error}</p>
            ))}
          </div>
        )}
      </div>

      <button type="submit">送信</button>
    </form>
  );
}
```

</div>
<div class="side-by-side-panel" data-label="テスト">

```tsx
// src/components/error-structure.test.tsx
import { render, screen } from "@testing-library/react";
import { describe, expect, it } from "vitest";
import type { SubmissionResult } from "@conform-to/dom";
import { ContactForm } from "./error-structure";

describe("ContactForm - フィールドエラーとフォームエラー", () => {
  it("フィールドエラーが各フィールドに表示される", () => {
    const lastResult: SubmissionResult<string[]> = {
      status: "error",
      initialValue: {
        name: "太郎",
        email: "invalid",
        message: "",
      },
      error: {
        email: ["メールアドレスの形式が正しくありません"],
        message: ["メッセージは10文字以上必要です"],
      },
    };

    render(<ContactForm lastResult={lastResult} />);

    expect(screen.getByText("メールアドレスの形式が正しくありません")).toBeInTheDocument();
    expect(screen.getByText("メッセージは10文字以上必要です")).toBeInTheDocument();
  });

  it("フォームエラーが表示される", () => {
    const lastResult: SubmissionResult<string[]> = {
      status: "error",
      initialValue: {
        name: "太郎",
        email: "taro@example.com",
        message: "こんにちは、お世話になっております",
      },
      error: {
        "": ["送信に失敗しました。時間をおいて再度お試しください"],
      },
    };

    render(<ContactForm lastResult={lastResult} />);

    expect(
      screen.getByText("送信に失敗しました。時間をおいて再度お試しください"),
    ).toBeInTheDocument();
  });

  // aria-invalid: 「この入力欄の値に問題がある」ことをスクリーンリーダーに伝える属性
  it("エラーがある場合aria-invalidがtrueになる", () => {
    const lastResult: SubmissionResult<string[]> = {
      status: "error",
      initialValue: {
        name: "太郎",
        email: "",
        message: "",
      },
      error: {
        email: ["メールアドレスは必須です"],
      },
    };

    render(<ContactForm lastResult={lastResult} />);

    const emailInput = screen.getByLabelText("メールアドレス");
    expect(emailInput).toHaveAttribute("aria-invalid", "true");

    // エラーのないフィールドにはaria-invalid="true"がない
    const nameInput = screen.getByLabelText("名前");
    expect(nameInput).not.toHaveAttribute("aria-invalid", "true");
  });

  // aria-describedby: inputとエラーメッセージ要素を紐づけ、スクリーンリーダーがエラー内容を読み上げられるようにする
  it("aria-describedbyがerrorIdを含みエラーメッセージと紐づく", () => {
    const lastResult: SubmissionResult<string[]> = {
      status: "error",
      initialValue: { name: "", email: "", message: "" },
      error: {
        email: ["メールアドレスは必須です"],
      },
    };

    render(<ContactForm lastResult={lastResult} />);

    const emailInput = screen.getByLabelText("メールアドレス");
    const ariaDescribedBy = emailInput.getAttribute("aria-describedby");
    expect(ariaDescribedBy).toBeTruthy();

    // aria-describedbyで参照されるエラー要素が存在する
    const errorElement = document.getElementById(ariaDescribedBy!.split(" ")[0]);
    expect(errorElement).not.toBeNull();
  });

  it("エラーなしの場合エラー要素が表示されない", () => {
    render(<ContactForm />);

    expect(screen.queryByRole("alert")).not.toBeInTheDocument();
  });
});
```

</div>
</div>

## まとめ

Conformはバリデーションライブラリではない。フォームのHTML属性生成、状態管理、エラーの振り分けを自動化するライブラリだ。

- **HTML属性の自動生成**: `getFormProps` / `getInputProps` が `id`, `name`, `required` などを付与する。`id` と `label` の紐づけも自動で管理される
- **フォーム状態管理**: `defaultValue` で初期値を宣言し、`lastResult` で送信結果を渡す。`form.status` や `fields.*.errors` のフォーマットが統一されているので、フォームごとに状態管理の形式がばらつかない
- **エラーの振り分け**: `error` のキーが `""` ならフォームエラー、フィールド名ならフィールドエラーに振り分けられる。`aria-invalid` と `aria-describedby` も自動で付与される
