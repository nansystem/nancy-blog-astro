---
title: 仕様駆動開発（SDD）入門：バイブコーディングの問題をKiroとspec-kitで解決する
description: バイブコーディングの問題を仕様駆動開発（SDD）がどう解決するかを解説。KiroとGitHub spec-kitのワークフロー、要件定義・設計・タスク分解の5フェーズ、PRレビュー負荷が下がる理由を整理する。
date: 2026-02-21T12:00:00+09:00
categories:
  - AI
permalink: /spec-driven-development
published: false
---

AI コーディングツールの普及により、自然言語でコードを生成する「バイブコーディング（Vibe Coding）」が急速に広まった。チャットで「こういう機能を作って」と伝えれば、AI がコードを生成してくれる。手軽で速い。しかし、この手軽さの裏にはいくつかの問題が潜んでいる。

仕様駆動開発（Spec-Driven Development、以下 SDD）は、この問題に対する構造的な回答である。

本記事では、SDD とは何か、なぜ生まれたのか、どうやって進めるのか、そしてなぜ PR レビューの負荷を軽減できるのかを整理する。

---

## バイブコーディングの何が問題なのか

バイブコーディングには以下の問題がある。

### 1. AI が要件を十分に理解する前にコードを生成し始める

開発者がプロンプトを投げると、AI は即座にコード生成に入る。要件を深掘りする前に実装が始まるため、「実はこういう意味だったんだけど」という手戻りが頻発する。Kiro の開発チームはこの問題を「AI は要件を十分に理解する前にコード生成にジャンプしてしまい、開発者は何度も意図を明確にしなければならない」と表現している。

### 2. コンテキストウィンドウが汚染される

何度もやり取りを重ねるうちに、コンテキストウィンドウが議論の往復で埋まる。肝心のコード生成に使える余地が減り、AI の出力品質が下がる。

### 3. 要件が消える

チャットベースのやり取りでは、合意した要件がチャット履歴の中に埋もれる。後から変更を加えるとき、以前の要件が失われやすい。なぜそうなったのかの意思決定の経緯も残らない。Kiro のブログでは、仕様ファイルがあれば「変更は requirements.md に追記され、会話履歴に埋もれることがない」と説明されている。

### 4. 全体像が欠落する

Kiro VP の Marc Brooker は、バイブコーディングには「プログラムが全体として何をすべきか、なぜそうすべきかという全体像が欠けている」と指摘している。逐次的なプロンプトでは、個々のコード片は生成できても、それらが一貫したシステムを構成するかは保証されない。

### 5. 大規模コードベースで破綻する

明確な要件がないまま AI にコードを書かせると、プロジェクトが大きくなるにつれて一貫性が失われる。ナレッジマネジメントの欠如により、技術的負債が蓄積される。

---

## 仕様駆動開発とは何か

仕様駆動開発（SDD）は、**仕様を先に書き、その仕様に基づいてテストと実装を導出する**開発手法である。

ここでいう「仕様」とは、**ソフトウェアが何をすべきか、どのようなニーズを満たすべきかを記述した、構造化された自然言語のドキュメント**のことである。仕様が主成果物であり、コードは「仕様を満たすこと」に従属する。

GitHub のブログでは、SDD を「コードを先に書いてドキュメントを後で書くのではなく、仕様（specs）から始める」アプローチと定義している。仕様は静的なドキュメントではなく、プロジェクトとともに進化する「生きた実行可能な成果物」として扱われる。

バイブコーディングとの違いを表にまとめる。

|            | バイブコーディング     | 仕様駆動開発                         |
| ---------- | ---------------------- | ------------------------------------ |
| 起点       | プロンプト（会話）     | 仕様（構造化ドキュメント）           |
| 要件の寿命 | チャット履歴に埋没     | バージョン管理された成果物として永続 |
| AI の役割  | コード生成             | 要件定義・設計・実装・検証すべて     |
| 変更時     | 新しいプロンプトで指示 | 仕様を更新し、差分を実装に反映       |
| デバッグ   | コードを直す           | 仕様を直す（→ コードを再生成）       |

GitHub spec-kit の文書では、SDD においては「デバッグ」が「不正なコードを生成する仕様を修正すること」に変わり、「リファクタリング」が「仕様を再構成すること」に変わると述べられている。これは開発ライフサイクル全体の変革を意味する。

---

## Kiro は何を目指していたのか

Kiro は Amazon が開発した AI 開発環境（IDE / CLI）で、2025 年 7 月にプレビュー版がリリースされた。Kiro は SDD を IDE レベルで実現した最初の本格的なツールであり、以下の問題を解決しようとしていた。

### 1950 年代以来のパラダイムシフト

Kiro VP の Marc Brooker は、SDD を「1950〜60 年代のプログラミング言語革命以来、最初の大きなプログラミングパラダイムシフト」と位置づけている。プログラミングの焦点が「どう解決するか（How）」から「何を解決するか（What）」に移行するという主張である。

### 仕様を「北極星」にする

仕様は AI エージェントの作業を導く「北極星」として機能する。Kiro のブログでは、仕様は「バージョン管理され、人間が読める"スーパープロンプト"」であると説明されている。仕様があれば、AI は大きなタスクに取り組んでも道に迷わない。仕様に書かれた要件は、追加の変更が行われても失われない。

### コンテキストの効率化

仕様ファイルが存在することで、実装時に AI は仕様ファイルを参照する。探索的な会話でコンテキストウィンドウを消費する代わりに、「最大限のコンテキスト空間が実際のコーディングタスクに使える」ようになる。

### 制度的記憶の構築

仕様は「生きたドキュメント」として機能し、なぜ特定の技術的選択がなされたかの監査証跡を残す。シニアエンジニアが離れても、意思決定の経緯が失われない。

### Kiro が確立した SDD のワークフロー

Kiro は SDD のワークフローを 3 つのフェーズに整理した。

1. **Requirements（要件定義）**: 自然言語のプロンプトから、ユーザーストーリーと EARS 形式の受け入れ条件を生成する
2. **Design（設計）**: コードベースを分析し、アーキテクチャ設計、データフロー図、インターフェース定義を生成する
3. **Tasks（タスク分解）**: 依存関係に基づいて順序付けられた、追跡可能な実装タスクを生成する

さらに、Kiro は**ステアリング（Steering）**という概念を導入した。これはプロジェクトの記憶を永続化する仕組みで、以下の 3 つのファイルから成る。

- **product.md**: プロダクトの概要、主要機能、対象ユーザー
- **tech.md**: 技術スタック、フレームワーク、技術的制約
- **structure.md**: ディレクトリ構成、アーキテクチャパターン、命名規約

ステアリングファイルは、AI エージェントがプロジェクトの文脈を理解するためのベースラインとして機能する。新しい機能を開発する際、AI はステアリングを参照して既存のアーキテクチャとの整合性を保つ。

### 実績

AWS のブログでは、Rackspace Technology が Kiro を使って「52 週分の見積もり作業を 3 週間で完了し、90% の効率向上を達成した」事例が紹介されている。また、創薬エージェントの開発にも SDD が適用され、3 週間で本番投入可能なシステムが構築された。

---

## GitHub spec-kit: もう一つの SDD ツール

GitHub も 2025 年にオープンソースの SDD ツールキット「spec-kit」をリリースした。Kiro とはアプローチが異なるため、両者を比較することで SDD の本質がより明確になる。

### spec-kit のワークフロー

spec-kit は 4 つのフェーズで構成される。

1. **Specify（仕様作成）**: 何を作るか、なぜ作るかを記述する。ユーザーシナリオ、受け入れ条件、エッジケースを含む
2. **Plan（設計）**: 技術的制約、アーキテクチャ、統合要件を明示する。データモデル、API 契約を含む
3. **Tasks（タスク分解）**: 仕様と設計をタスクに分解する。各タスクは独立してテスト可能
4. **Implement（実装）**: AI がタスクに基づいて実装する

### spec-kit の独自概念: Constitution（憲法）

spec-kit が Kiro と大きく異なるのは、**Constitution（憲法）**という概念を持つ点である。これはプロジェクトの不変の原則を定めたドキュメントで、すべての仕様と設計がこの原則に準拠しなければならない。

たとえば、以下のような条項が定義される。

- **ライブラリファースト原則**: すべての機能はまず独立したライブラリとして始める
- **テストファースト命令**: テストが書かれ、失敗が確認されるまで実装コードを書いてはならない
- **反抽象化**: フレームワークの機能を直接使い、不要なラッパーを避ける

Constitution は実装判断のゲートとして機能し、設計フェーズで「Constitution Check」が行われる。

### Kiro と spec-kit の比較

| 観点             | Kiro                                          | spec-kit                                           |
| ---------------- | --------------------------------------------- | -------------------------------------------------- |
| 提供元           | Amazon                                        | GitHub                                             |
| 形態             | IDE / CLI                                     | CLI ツールキット                                   |
| ワークフロー     | Requirements → Design → Tasks                 | Specify → Plan → Tasks → Implement                 |
| プロジェクト記憶 | Steering（product.md, tech.md, structure.md） | Constitution（不変の原則）                         |
| 受け入れ条件     | EARS 形式                                     | Given-When-Then 形式                               |
| 対応 AI          | Kiro 内蔵                                     | 20+ エージェント対応（Claude, Copilot, Gemini 等） |
| 成果物の場所     | `.kiro/specs/{feature}/`                      | `specs/{feature}/`                                 |

両者に共通するのは、**仕様を先に書き、AI に仕様に基づいて実装させる**という SDD の核心的アプローチである。

---

## SDD の進め方: 5 つのフェーズ

SDD の一般的なワークフローを、各フェーズの目的・やること・成果物に分けて説明する。

### Phase 1: 要件定義

**目的**: 「何を作るか」を明確にする。

**やること**:

- 自然言語で機能の説明を書く
- AI が要件ドキュメントを生成する
- 要件ごとにユーザーストーリーと受け入れ条件を記述する
- 正常系・異常系・境界条件を網羅する

**成果物**: `requirements.md`

**受け入れ条件の書き方: EARS 形式**

SDD では受け入れ条件を EARS（Easy Approach to Requirements Syntax）形式で書くことが多い。EARS 形式は要件を以下の 5 パターンに分類する。

| パターン             | 構文                               | 例                                                                                                |
| -------------------- | ---------------------------------- | ------------------------------------------------------------------------------------------------- |
| イベント駆動         | 〜が起きたとき、システムは〜する   | ユーザーがログインボタンをクリックしたとき、システムは認証処理を開始しなければならない            |
| 状態駆動             | 〜ならば、システムは〜する         | ユーザーが認証済みならば、システムはダッシュボードを表示しなければならない                        |
| 望ましくない振る舞い | 〜が発生した場合、システムは〜する | データベース接続が失敗した場合、システムはエラーをログに記録し 5 秒後にリトライしなければならない |
| 任意機能             | 〜を含む場合、システムは〜する     | 二要素認証が有効な場合、システムは SMS コードをユーザーに送信しなければならない                   |
| 常時                 | システムは常に〜する               | システムは常にトランザクションの一貫性を維持しなければならない                                    |

EARS 形式で書くことで、受け入れ条件が自然とテスト可能になる。「適切に処理する」「素早く応答する」といった曖昧な表現は排除され、検証可能な条件が残る。

**要件の品質チェック**:

以下に該当する要件はリジェクトする。

- **曖昧な修飾語**: 「適切に」「素早く」「十分に」→ 数値で定量化する（「2 秒以内」）
- **複数の振る舞いの混在**: 「〜を検証し、かつフォーマットする」→ 要件を分割する
- **主語が不明確**: 「それは応答する」→ 具体的なモジュール名を明記する
- **テスト不可能**: 「システムは高速であること」→ 計測可能な基準を設ける
- **実装の指定**: 「SHA-256 アルゴリズムを使って」→ 「パスワードを安全にハッシュ化する」

**要件ドキュメントの構造例**:

```markdown
# 要件ドキュメント

## 導入

ユーザー認証機能を実装する。メールアドレスとパスワードによるログイン、
セッション管理、パスワードリセットを含む。

## 実装コンテキスト

- **既存実装**: なし
- **判定根拠**: src/auth/ ディレクトリが存在しないことを確認

## 要件

### 要件 1: ユーザーログイン

**目的:** ユーザーとして、メールとパスワードでログインし、
自分のアカウントにアクセスしたい。

#### 受け入れ条件

1. ユーザーが有効なメールアドレスとパスワードを送信したとき、
   システムは認証トークンを返却しなければならない
2. ユーザーが無効なパスワードを 5 回連続で送信した場合、
   システムはアカウントを 15 分間ロックしなければならない
3. 認証トークンは常に発行から 24 時間で失効しなければならない
```

### Phase 2: 設計

**目的**: 「どう作るか」の設計を決める。

**やること**:

- 既存のコードベースを調査する（ディスカバリ）
- アーキテクチャの概要を定義する
- コンポーネントとインターフェースを設計する
- データモデルを定義する
- 要件とコンポーネントの対応表（トレーサビリティテーブル）を作成する
- エラー処理戦略とテスト戦略を策定する

**成果物**: `design.md`, `research.md`（調査ログ）

**設計の原則**:

- **Type Safety**: 型は明示的に定義する。any 型は禁止
- **WHAT, not HOW**: 何をするかを記述し、どう実装するかは書かない
- **トレーサビリティ**: すべてのコンポーネントを要件 ID に紐づける
- **自己完結性**: 設計ドキュメント単体でレビューが可能であること

**要件トレーサビリティテーブルの例**:

| 要件 | サマリー                   | コンポーネント      | インターフェース                         |
| ---- | -------------------------- | ------------------- | ---------------------------------------- |
| 1.1  | メールとパスワードで認証   | AuthService         | authenticate(email, password): AuthToken |
| 1.2  | 5 回失敗でアカウントロック | LoginAttemptTracker | recordFailure(userId): void              |
| 1.3  | トークンは 24 時間で失効   | TokenManager        | createToken(userId): AuthToken           |

このテーブルがあることで、設計ドキュメントを見るだけで「この要件はどのコンポーネントが担当するのか」が一目瞭然になる。

### Phase 2.5: 設計レビュー（GO/NO-GO 判定）

**目的**: 実装に進んでよいかを判定する。

**やること**:

- 以下の 4 つの観点で設計をレビューする
  1. **既存アーキテクチャとの整合性**（最優先）: 既存のシステム境界・レイヤー構成と矛盾しないか
  2. **設計の一貫性と標準準拠**: 命名規約、エラー処理、設定管理に統一性があるか
  3. **拡張性と保守性**: 関心の分離、テスト可能性、複雑度の妥当性
  4. **型安全性とインターフェース設計**: 型定義、API 境界、入力バリデーション
- 重大な問題は**最大 3 件**に絞る
- 設計の良い点を 1〜2 点挙げる
- GO（実装に進む）または NO-GO（設計を修正する）を判定する

**成果物**: `design-review.md`

**GO/NO-GO の判定基準**:

| 判定  | 条件                                                                                           |
| ----- | ---------------------------------------------------------------------------------------------- |
| GO    | 重大なアーキテクチャ上の不整合がない。要件が網羅されている。実装パスが明確。リスクが許容範囲内 |
| NO-GO | 根本的な矛盾がある。重大なギャップがある。失敗リスクが高い。要件に対して複雑度が不釣り合い     |

この設計レビューは、**実装前に設計の問題を検出するためのゲート**である。Kiro のブログでは「仕様フェーズは、人間がリソースを投入する前に方向性をレビュー・修正・承認できる自然な一時停止点を作り出す」と説明されている。

### Phase 3: タスク分解

**目的**: 実装作業を具体的なタスクに分解する。

**やること**:

- 設計ドキュメントに基づいてタスクを生成する
- タスクは自然言語で記述する（ファイルパスや関数名は書かない）
- 各タスクに対応する要件 ID を紐づける
- 並列実行可能なタスクに `(P)` マーカーを付ける
- 最大 2 階層までのネスト

**成果物**: `tasks.md`

**タスクの記述例**:

```markdown
# 実装タスク: ユーザー認証

- [ ] 1. 認証基盤の構築
- [ ] 1.1 パスワードのハッシュ化と検証を行うモジュールを作成する
  - ハッシュ生成と照合の 2 つの関数を提供する
  - _Requirements: 1.1_
- [ ] 1.2 (P) 認証トークンの生成・検証・失効を管理するモジュールを作成する
  - トークンに有効期限を設定し、失効を自動判定する
  - _Requirements: 1.3_

- [ ] 2. ログイン機能の実装
- [ ] 2.1 ログインエンドポイントを作成する
  - メールとパスワードを受け取り、認証トークンを返す
  - _Requirements: 1.1_
- [ ] 2.2 ログイン失敗回数を追跡し、閾値超過でロックする機能を実装する
  - _Requirements: 1.2_
```

### Phase 4: 実装

**目的**: タスクに基づいてコードを実装する。

**やること**:

- タスクリストを分析し、実行計画を作成する
- 依存関係のないタスクは並列で実行する
- 完了したタスクのチェックボックスを更新する
- すべての実装判断は仕様と設計に基づく

### Phase 5: 実装検証

**目的**: 実装が仕様を満たしているかを検証する。

**やること**:

以下の 3 つの観点で並列レビューを行う。

1. **アーキテクチャレビュー**: コンポーネント構成が設計と一致するか
2. **QA レビュー**: テストカバレッジ、受け入れ条件のテスト網羅性
3. **実装検証**: タスクの完了状況、要件カバレッジ、テスト結果

**成果物**: `impl-validation.md`（APPROVE / REJECT 判定）

---

## なぜ SDD で PR レビューの負荷が軽減するのか

SDD が PR レビュー負荷を軽減する理由を、具体的なメカニズムに分解して説明する。

### 1. 設計レビューと実装レビューが分離される

従来の開発では、PR レビュアーはコードを読みながら同時に「この設計は妥当か」「要件を満たしているか」「コードの品質は十分か」を判断していた。

SDD では、設計レビュー（Phase 2.5）が実装の前に行われる。PR レビュー時には**設計の妥当性はすでに合意されている**ため、レビュアーはコードの品質と設計への準拠だけに集中できる。

### 2. 「このコードは何をしようとしているのか」を推測する必要がない

従来の PR レビューで最も認知負荷が高いのは、**コードからレビュアーが実装者の意図を逆算する**作業である。

SDD では、要件ドキュメント、設計ドキュメント、タスクリストが存在するため、レビュアーは「何をしようとしているか」を推測する必要がない。仕様という「正解」が手元にある状態で、コードがそれに合致しているかを確認するだけでよい。

### 3. 要件トレーサビリティによりスコープが明確になる

設計ドキュメントには要件 ID とコンポーネントの対応表がある。タスクリストにも要件 ID が紐づいている。

レビュアーは「この PR はどの要件を実装しているのか」「この変更のスコープは妥当か」を一目で判断できる。

### 4. コンテキストの効率化

Kiro のブログでは、仕様ファイルが存在することで「実装フェーズで AI は仕様ファイルを参照し、探索的な会話でコンテキストウィンドウを浪費しない」と説明されている。同じことが人間のレビュアーにも当てはまる。広範なチャット履歴を解析する代わりに、集中的なマークダウンドキュメントで具体的な設計判断を評価できる。

### 5. 手戻りが減る

設計レビューの GO/NO-GO ゲートにより、実装前にアーキテクチャ上の問題が検出される。Kiro のブログでは「開発途中に要件の問題を発見するのではなく、事前に曖昧さを特定・解決する。これによりコストのかかる書き直しを防ぎ、コーディング開始前に方向性を揃える」と述べられている。

### 6. ドキュメントが常に最新

SDD では仕様がプロセスの一部として作成・更新されるため、「ドキュメントが実装と乖離する」問題が起きにくい。Kiro のブログでは「ドキュメントは後付けではなくプロセスに不可欠なものであるため、常に最新の状態を保つ」と述べられている。

---

## SDD の理想と現実

SDD は強力な手法だが、万能ではない。cc-sdd（SDD ツール）の開発者による発表と Martin Fowler サイトの分析記事から、現実の課題を整理する。

### 仕様の肥大化

cc-sdd の開発者の発表では、比較的シンプルな機能でも AI が生成した仕様が 3,590 行以上に膨れ上がったケースが報告されている。個別の仕様が 900 行を超える場合もあった。「現在の SDD ツールは固定的で高負荷なワークフローを持ち、タスクの規模に応じた適切なサイズの仕様を作ることが難しい」という指摘がある。

### 仕様の正確性を検証する仕組みがない

LLM は確率的な出力を生成するため、仕様だけでは実装の正確性を保証できない。「実装後に仕様の正確性を検証するメカニズムがない」という根本的なギャップが指摘されている。

### エンジニアだけでは完結しない

SDD はエンジニアだけでは完結しない。プロダクトオーナー、マネージャー、ビジネスアナリスト、QA エンジニアが協働する必要がある。組織のプロセス変更を伴う。

### Martin Fowler サイトの批判

Martin Fowler のサイトに掲載された分析記事では、「私はこれらのマークダウンファイルをすべてレビューするよりも、コードをレビューしたい。効果的な SDD ツールは非常に良い仕様レビュー体験を提供しなければならない」という指摘がある。

### SDD が向いている領域・向いていない領域

**向いている領域**:

- 明確な境界を持つ安定した領域（外部 API、データベース整合性）
- 高リスク・規制のある分野（金融計算）
- 要件と開発を分離する組織構造がある場合
- モジュラーなアーキテクチャ

**向いていない領域**:

- 「未知の未知」が多い探索的な開発
- 小さなタスクや単純な修正
- 要件自体がまだ固まっていない初期フェーズ

### 現実的な導入指針

1. まず CI/CD を整備し、高速な評価サイクルを回せるようにする
2. モジュラーなシステム設計で複雑性を最小化する
3. 最小限の仕様から始め、組織のニーズに応じて段階的に拡充する

---

## SDD の成果物の全体像

SDD の各フェーズで生成される成果物を整理する。

```
.kiro/specs/{feature}/
  requirements.md      ... Phase 1: 要件（EARS 形式）
  gap-analysis.md      ... Phase 1.5: ギャップ分析（既存実装がある場合）
  design.md            ... Phase 2: 技術設計
  research.md          ... Phase 2: 調査ログ（設計判断の根拠）
  design-review.md     ... Phase 2.5: 設計レビュー（GO/NO-GO）
  tasks.md             ... Phase 3: 実装タスクリスト
  impl-validation.md   ... Phase 5: 実装検証（APPROVE/REJECT）

.kiro/steering/
  product.md           ... プロダクトの概要
  tech.md              ... 技術スタック
  structure.md         ... プロジェクト構造
```

この構造は Kiro のフォーマットに由来する。成果物はすべてマークダウン形式であり、Git でバージョン管理できる。

---

## SDD を始めるためのチェックリスト

SDD を自分のプロジェクトで始める際の最小限のステップを示す。

1. **機能の説明を自然言語で書く**: 「何を作るか」を 1 段落で書く
2. **要件を EARS 形式で書く**: 受け入れ条件を 5 つのパターンに当てはめる
3. **設計ドキュメントを書く**: コンポーネント、インターフェース、要件トレーサビリティテーブルを含める
4. **設計をレビューする**: GO/NO-GO を判定してから実装に進む
5. **タスクを分解する**: 自然言語で書き、要件 ID を紐づける
6. **実装と検証**: タスクに基づいて実装し、仕様に対して検証する

すべてのフェーズを一度に導入する必要はない。まずは Phase 1（要件定義）だけでも十分に効果がある。要件を EARS 形式で明文化するだけで、AI の出力品質は大きく改善する。

---

## まとめ

仕様駆動開発は、AI 時代の開発プロセスに構造を与える手法である。

- **バイブコーディングの問題**: 要件が曖昧なまま実装が始まり、手戻りが多く、要件が消失し、全体像が欠落する
- **SDD の解決策**: 仕様を先に書き、仕様を「北極星」として実装を導く。デバッグもリファクタリングも仕様レベルで行う
- **Kiro の貢献**: SDD を Requirements → Design → Tasks の 3 フェーズワークフローとして確立し、Steering（プロジェクト記憶）の概念を導入した
- **spec-kit の貢献**: Constitution（不変の原則）の概念を導入し、20 以上の AI エージェントに対応するオープンなツールキットを提供した
- **PR レビュー負荷の軽減**: 設計レビューと実装レビューの分離、要件トレーサビリティ、コンテキストの効率化、手戻りの削減によって実現される
- **現実的な課題**: 仕様の肥大化、検証の困難さ、組織的な変更の必要性がある
- **導入の指針**: タスクの規模に応じてプロセスの重さを調整する。小さなタスクには適用しない。最小限の仕様から始める

SDD の本質は「仕様を検証可能な形で先に固定し、実装を仕様に従属させる」ことにある。AI が実装の主体になりつつある時代において、人間の仕事は「何を作るか」を正確に定義することへとシフトしている。SDD はそのシフトを構造化したものである。

---

## 参考資料

- [Kiro 公式サイト](https://kiro.dev/)
- [Kiro and the future of AI spec-driven software development](https://kiro.dev/blog/kiro-and-the-future-of-software-development/)
- [From chat to specs: a deep dive into AI-assisted development with Kiro](https://kiro.dev/blog/from-chat-to-specs-deep-dive/)
- [チャットから仕様へ : Kiro を用いた AI 支援開発の深掘り（AWS ブログ日本語版）](https://aws.amazon.com/jp/blogs/news/from-chat-to-specs-deep-dive/)
- [From spec to production: a three-week drug discovery agent using Kiro](https://aws.amazon.com/blogs/industries/from-spec-to-production-a-three-week-drug-discovery-agent-using-kiro/)
- [Spec-driven development with AI: Get started with a new open source toolkit（GitHub Blog）](https://github.blog/ai-and-ml/generative-ai/spec-driven-development-with-ai-get-started-with-a-new-open-source-toolkit/)
- [GitHub spec-kit リポジトリ](https://github.com/github/spec-kit)
- [Agentic AI, MCP, and spec-driven development: Top blog posts of 2025（GitHub Blog）](https://github.blog/developer-skills/agentic-ai-mcp-and-spec-driven-development-top-blog-posts-of-2025/)
- [Understanding Spec-Driven-Development: Kiro, spec-kit, and Tessl（Martin Fowler）](https://martinfowler.com/articles/exploring-gen-ai/sdd-3-tools.html)
- [仕様駆動開発の理想と現実、そして向き合い方（Speaker Deck）](https://speakerdeck.com/gotalab555/shi-yang-qu-dong-kai-fa-noli-xiang-toxian-shi-sositexiang-kihe-ifang)
